----------------------------------------------


-----------------------------------------------
20131014 canPerform

ターン途中でmpが変化して魔法が使えなくなる場合もありえる。
実際に使う時の判定も必要。
使えなかったなどの結果ログも必要か。
行動を制限するスキルなどもあってもいいか。

途中で死んだときも攻撃できない。

攻撃で相手が死んでいるときどうするか。
とりあえずはただ失敗する。
ほとんどのゲームでは生きている別の敵を攻撃する気がする

bufも生きているカードの分だけスタックに積む
死んだときに消す

execActionにもTargetCapacityを渡した方がいい?


-----------------------------------------------
20131012 バトルログ


Aの攻撃, Bにxのダメージ
など
Bは防御した、Bの防御力がxアップ
CはDに回復魔法を使った。Dのhpがx回復した
Eの効果が切れた
Fは力尽きた

Player Card Attack [(Player, Card, Damage)]
Player Card Defense [(Player, Card, DefenseUp)]
Player Card Heal [(Player, Card, HealHp)]

BattleCommand Dif

BattleLog, TurnLog, BattleStateSnapShot

TurnLog
initialState

data ActionResult =
    StateChange Player Int CardState Int |
    PropertyChange Player Int PropertySet
    Death Player Int

data BattleLog =
    StateSnapshot BatteState |
    TurnLog [BattleCommandLog]

EffectExpiration
Death

----------------------------------------------
20131006 Card, Effect

関数を直接持つと表示しにくい
シリアライズしにくい

変えたほうがいいか

Targetable
Skill
BattleEffect

エフェクトの関数は掛け算だけにして、対象プロパティと値だけであらわすなど
Targetableはタグ用のEnum型と対応させるなど, タグの合成からもTargetableを作れればよさそう
そんなに数ないので全部Enumでもよいか
SkillはTargetableがShowのインスタンスになれば可視化ok



----------------------------------------------
20131002 テスト

hspecとQuickCheckのテストをなんとなく覚えた

propはTest.Hspec.QuickCheckに含まれる
ランダムに複数回行うテスト
prop :: Testable prop => String -> prop -> Spec
引数二つテストの説明文とテスト内容
Gen aもTestable
引数がArbitraryのインスタンスであれば関数もTestable
結果の表示のために引数がShowのインスタンスである必要がある
Arbitraryはランダムに値を生成するための定義
結果はBoolとかResultとかPropとかTestable?
propだとテスト内容表示あたりも適当に書く必要ある。

hspecのテストはSpecモナドをつなげるような感じで書く

hspec-discoverを使うと、ソースのディレクトリ構造と対応するテストファイルを実行する。
ファイルHoge.hsの場合テストはHogeSpec.hs
module名Hogeの場合はHogeSpec
ディレクトリ深くなっても同じ

Spec.hsというファイルに
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
と書く

書くファイルにspec :: Specを定義する。

----------------------------------------------
20130925 Actionの型をどうするか。

カードごとの行動可能なアクションは
攻撃とか防御、回復と
ターゲットのタイプと
ターゲットの関係があればいいのか
攻撃は一体向けだけで、身方にはできないなど。
防御は自分にしかできない。

攻撃の処理をする関数も、一体、敵チームなどターゲットを変えて
実行できる必要がある。



---------------------------------------------------------------------
20130923 hspec

cabal install hspec
cabal install hspec-discover

hspec-discoverは~/.cabal/bin以下にあるのでPATHに追加する必要があるっぽい
hspec-discoverはソースのファイルに対応するテストファイルを探してくる機能

cabalはsandboxを使った方がいい?
sandboxが何かよくわからない。後で調べる

cabal configure --enable-tests
cabal build
cabal test


------------------------------------------------------------------------
20130921 エラー処理どうするか

IOの層で対応できていれば、その下ではバグ以外のエラーはないはず。
でもIOをいくつか書くとすれば、バグが入り込む余地はかなりある。
assertか何かでエラーチェックを入れておきたい。
それか、ErrorTでエラーの層も入れておくか

エラーが入る可能性があるところ
存在しないカードへのコマンド入力
カードが実行可能でないコマンド入力
など

テストを入れる。
QuickCheck?
HUnit?
hspec?

スピードは気にすることないはずなので、エラーの層を入れるか。
各関数でチェックするのは面倒なので、入力のあとにチェック処理を入れればいいか。


-------------------------------------------------------------------------------
20130921 

魔法の消費mpをどうするか。
普通のゲームではどうなってるか?
魔法にレベルがあって、レベルごとに消費mp, 効果が決まっていたり?
消費mp, 効果が固定で何段階か似たような魔法があったり。
レベル面倒なので、固定値でやってみる。
魔法は消費mpを決める必要がある
消費mpを取得する関数か何かがあればいいか

あと、消費mpが足りないとき使えないので
使えるかどうか判定する関数も必要か

プレイヤーのコマンドを受け取ったときに、実行可能かどうか返す
canPeform


-----------------------------------------------------------------------------------


関数から名前を取得するのは難しい。

名前 -> 関数 のマップ
を作っておいて

名前を記録するようにすれば処理を再現できる?
引数の取得手段も必要そう

どのプレイヤーが、どのカードで、どの敵プレイヤーの、どのカードを、どうした

攻撃なら、攻撃対象があるが、防御ならない
Actionの方に入れればよい?

PlayerTag CardTag 

BattleLog {player :: PlayerTag, card :: CardTag, action :: Action}

replayStep :: BattleLog -> BattleState -> BattleState

execAction

===
まとまらない


ログはコマンドを記録すればよいはず
状態はコマンド通り実行すれば同じ推移

状態は、変化するのとしないのでわけた方がいい?
まあ、後でもいい。
プレイヤーから、いじれるわけではない。
バグが入るかもしれないというのはある。

単純でいいので細かいルールを決める

===
1対1のバトル

何枚かのカードを持って、戦わせる。
カードの枚数をどうするか。
適当に上限決めて、Listに入れる
Maybeとかで一部カードなしも可能。
カード0枚はダメ。

カードのプロパティ
maxHp
attack
defense
speed


アクション
- 攻撃
相手のhpを減らす
とりあえず
相手のHP -= 攻撃力 - 防御力

- 防御
防御力が増える?
意味ないのでは?
1対1では意味ない。
回復できる状況などでは、たまに意味あるか。
攻撃よりも速くできないと、まったく意味ない。

- ブースト
ステータスが増える
防御力、スピード、攻撃力
実装的には、ブースト分を持つフィールドを作って
足して使う。
何ターンで消えるなども必要。
防御もこれの一種か。

- 魔法
MPを消費する。効果は色々。
とりあえず回復だけ。
回復量は固定で。


====
ターンの処理の流れ
コマンドを受け取る, コマンドのリストでいいか
コマンドを実行順にソートする
ログを残しつつ、コマンド実行し、状態更新
結果返す


PlayerCommand
BattleCommandをOrdにすればソートできるか

===
カードは、位置をキーにしたマップで持てばいいか。

data CardPosition = Card1 | Card2 | Card3 | Card4 | Card5 deriving (Show, Eq, Ord, Enum)

Map CardPosition Card














