{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE TemplateHaskell        #-}
{-# LANGUAGE TypeSynonymInstances   #-}
{-# LANGUAGE RankNTypes             #-}
{-# LANGUAGE UndecidableInstances   #-}
{-# LANGUAGE OverlappingInstances   #-}
{-# LANGUAGE ScopedTypeVariables    #-}
module Battle.Types
    ( Player(..)
    , Target(..)
    , PropertySet(..)
    , PropertyTag(..)
    , Action(..)
    , TargetCapacity(..)
    , Skill(..)
    , Card(..)
    , CardState(..)
    , BattleEffect(..)
    , BattleSetting(..)
    , BattleState(..)
    , BattleCommand(..)
    , PlayerCommand(..)
    , ActionChoice(..)
    , CommandChoice(..)
    , ActionResult(..)
    , EffectExpiration(..)
    , BattleLog(..)
    , BattleCommandLog(..)
    , playerAccessor
    , propertyAccessor
    , opponentPlayer
    , onTarget
    , BattleTurn

    -- generated by Lens
    , maxHp
    , maxMp
    , attack
    , defense
    , speed
    , magic
    , action
    , actions
    , target
    , targets
    , name
    , properties
    , property
    , skills
    , hp
    , mp
    , factor
    , first
    , second
    , maxTurn
    , oneTurnEffects
    , effects
    , turn
    , cardIndex
    , skillIndex
    , targetIndex
    , player
    , HasFirst
    , HasSecond
    ) where

import Control.Lens hiding (Action)
import Control.Monad (mzero)
import Control.Monad.Error (ErrorT)
import Control.Monad.Trans.RWS (RWS)
import qualified Data.Aeson as DA (Value(..), FromJSON, ToJSON, parseJSON, toJSON)
import qualified Data.Aeson.TH as DA (deriveJSON, Options(..), defaultOptions, SumEncoding(..))
import qualified Data.Scientific as S (scientific, coefficient, base10Exponent)


class (Enum a, Bounded a) => EnumJSON a

data Player = FirstPlayer | SecondPlayer deriving (Show, Eq, Enum, Bounded)
instance EnumJSON Player

data Target =
    TargetAll |
    TargetTeam Player |
    TargetCard Player Int deriving (Show, Eq)
$(DA.deriveJSON DA.defaultOptions ''Target)

data PropertySet = PropertySet {
    _propertysetMaxHp :: Int,
    _propertysetMaxMp :: Int,
    _propertysetAttack :: Int,
    _propertysetDefense :: Int,
    _propertysetSpeed :: Int,
    _propertysetMagic :: Int
    } deriving (Show, Eq)
$(makeFields ''PropertySet)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_propertyset") }) ''PropertySet)

data PropertyTag =
    MaxHpTag |
    MaxMpTag |
    AttackTag |
    DefenseTag |
    SpeedTag |
    MagicTag deriving (Show, Eq, Ord, Enum, Bounded)
instance EnumJSON PropertyTag

data Action =
    Defense Int |
    Attack Int |
    Heal Int Int |
    Buff PropertyTag Int Int Int
    deriving (Show, Eq, Ord)
$(DA.deriveJSON DA.defaultOptions { DA.sumEncoding = DA.ObjectWithSingleField } ''Action)

data TargetCapacity =
    TcAlmighty |
    TcOne |
    TcAliveOne |
    TcDeadOne |
    TcTeam |
    TcAll |
    TcOpponentOne |
    TcAliveOpponentOne |
    TcDeadOpponentOne |
    TcOpponentTeam |
    TcOwnOne |
    TcAliveOwnOne |
    TcDeadOwnOne |
    TcOwnTeam |
    TcSelf deriving (Show, Eq, Ord, Enum, Bounded)
instance EnumJSON TargetCapacity

data Skill = Skill {
    _skillName :: String,
    _skillAction :: Action,
    _skillTarget :: TargetCapacity
    } deriving (Show, Eq)
$(makeFields ''Skill)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_skill") }) ''Skill)

data Card = Card {
    _cardName :: String,
    _cardProperties :: PropertySet,
    _cardSkills :: [Skill]
    } deriving (Show, Eq)
$(makeFields ''Card)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_card") }) ''Card)

data CardState = CardState {
    _cardstateHp :: Int,
    _cardstateMp :: Int
} deriving (Show, Eq)
$(makeFields ''CardState)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_cardstate") }) ''CardState)

data BattleEffect = BattleEffect {
    _battleeffectTarget :: (Player, Int),
    _battleeffectProperty :: PropertyTag,
    _battleeffectFactor :: Int
    } deriving (Show, Eq)
$(makeFields ''BattleEffect)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_battleeffect") }) ''BattleEffect)

data BattleSetting = BattleSetting {
    _battlesettingFirst :: [Card],
    _battlesettingSecond :: [Card],
    _battlesettingMaxTurn :: Maybe Int
    } deriving (Show, Eq)
$(makeFields ''BattleSetting)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_battlesetting") }) ''BattleSetting)

data BattleState = BattleState {
    _battlestateFirst :: [CardState],
    _battlestateSecond :: [CardState],
    _battlestateOneTurnEffects :: [BattleEffect],
    _battlestateEffects :: [(BattleEffect, Int)],
    _battlestateTurn :: Int
    } deriving (Show, Eq)
$(makeFields ''BattleState)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_battlestate") }) ''BattleState)

data PlayerCommand = PlayerCommand {
    _playercommandCardIndex :: Int,
    _playercommandSkillIndex :: Int,
    _playercommandTargetIndex :: Int
    } deriving (Show, Eq)
$(makeFields ''PlayerCommand)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_battlecommand") }) ''PlayerCommand)

data BattleCommand = BattleCommand {
    _battlecommandPlayer :: Player,
    _battlecommandCardIndex :: Int,
    _battlecommandSkillIndex :: Int,
    _battlecommandAction :: Action,
    _battlecommandTarget :: Target
    } deriving (Show, Eq)
$(makeFields ''BattleCommand)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_battlecommand") }) ''BattleCommand)

data ActionChoice = ActionChoice {
    _actionchoiceSkillIndex :: Int,
    _actionchoiceAction :: Action,
    _actionchoiceTargets :: [Target]
    } deriving (Show, Eq)
$(makeFields ''ActionChoice)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_actionchoice") }) ''ActionChoice)

data CommandChoice = CommandChoice {
    _commandchoiceCardIndex :: Int,
    _commandchoiceActions :: [ActionChoice]
    } deriving (Show, Eq)
$(makeFields ''CommandChoice)
$(DA.deriveJSON (DA.defaultOptions { DA.fieldLabelModifier = drop (length "_commandchoice") }) ''CommandChoice)

-- log
data ActionResult =
    Consume (Player, Int) CardState |
    StateChange (Player, Int) CardState |
    PropertyChange (Player, Int) PropertyTag Int |
    Death (Player, Int) |
    FailureBecauseDeath |
    Underqualified |
    ActionFailure deriving (Show, Eq)
$(DA.deriveJSON DA.defaultOptions ''ActionResult)

newtype EffectExpiration = EffectExpiration BattleEffect deriving (Show, Eq)
$(DA.deriveJSON DA.defaultOptions ''EffectExpiration)

data BattleCommandLog =
    BattleCommandLog BattleCommand [ActionResult] deriving (Show, Eq)
$(DA.deriveJSON DA.defaultOptions ''BattleCommandLog)

data BattleLog = BattleLog BattleState [BattleCommandLog] [EffectExpiration] deriving (Show, Eq)
$(DA.deriveJSON DA.defaultOptions ''BattleLog)

-- BattleTurn
type BattleTurn = ErrorT String (RWS BattleSetting () BattleState)

onTarget :: Player -> Int -> Target -> Bool
onTarget _ _ TargetAll = True
onTarget q _ (TargetTeam p) = p == q
onTarget q y (TargetCard p x) = p == q && x == y

playerAccessor :: (HasFirst a b, HasSecond a b)
               => Player -> Lens' a b
playerAccessor FirstPlayer = first
playerAccessor SecondPlayer = second

propertyAccessor :: (HasMaxHp a b, HasMaxMp a b, HasAttack a b, HasDefense a b, HasSpeed a b, HasMagic a b)
                 => PropertyTag -> Lens' a b
propertyAccessor MaxHpTag = maxHp
propertyAccessor MaxMpTag = maxMp
propertyAccessor AttackTag = attack
propertyAccessor DefenseTag = defense
propertyAccessor SpeedTag = speed
propertyAccessor MagicTag = magic

opponentPlayer :: Player -> Player
opponentPlayer FirstPlayer = SecondPlayer
opponentPlayer SecondPlayer = FirstPlayer

-- for Enum conversion
instance (EnumJSON a) => DA.FromJSON a where
    parseJSON (DA.Number s) = case safeToEnum $ fromInteger c of
                                   Just e -> return e
                                   Nothing -> mzero
                              where c = S.coefficient s
    parseJSON _ = mzero

instance (EnumJSON a) => DA.ToJSON a where
    toJSON e = DA.Number . flip S.scientific 0 . toInteger . fromEnum $ e

safeToEnum :: forall t . (Enum t, Bounded t) => Int -> Maybe t
safeToEnum i = if (i >= fromEnum (minBound :: t)) && (i <= fromEnum (maxBound :: t))
                  then Just . toEnum $ i
                  else Nothing

